#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble

%------------------------------------------------------------------------------
%	REQUIRED PACKAGES AND  CONFIGURATIONS
%------------------------------------------------------------------------------
% PACKAGES FOR TITLES
\usepackage{titlesec}
\usepackage{color}
% PACKAGES FOR LANGUAGE AND FONT
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc} % Font encoding

% PACKAGES FOR IMAGES
\usepackage{graphicx}
\graphicspath{{Images/}}
\usepackage{eso-pic} % For the background picture on the title page
\usepackage{subfig} % Numbered and caption subfigures using \subfloat
\usepackage{caption} % Coloured captions
\usepackage{transparent}

% STANDARD MATH PACKAGES
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{bm}
\usepackage[overload]{empheq}  % For braced-style systems of equations

% PACKAGES FOR TABLES
\usepackage{tabularx}
\usepackage{longtable} % tables that can span several pages
\usepackage{colortbl}

% PACKAGES FOR ALGORITHMS (PSEUDO-CODE)
\usepackage{algorithm}
\usepackage{algorithmic}

% PACKAGES FOR REFERENCES & BIBLIOGRAPHY
\usepackage[colorlinks=true,linkcolor=black,anchorcolor=black,citecolor=black,filecolor=black,menucolor=black,runcolor=black,urlcolor=black]{hyperref} % Adds clickable links at references
\usepackage{cleveref}
\usepackage[square, numbers, sort&compress]{natbib} % Square brackets, citing references with numbers, citations sorted by appearance in the text and compressed
\bibliographystyle{plain} % You may use a different style adapted to your field

% PACKAGES FOR THE APPENDIX
\usepackage{appendix}

% PACKAGES FOR ITEMIZE & ENUMERATES 
\usepackage{enumitem}

% OTHER PACKAGES
\usepackage{amsthm,thmtools,xcolor} % Coloured "Theorem"
\usepackage{comment} % Comment part of code
\usepackage{fancyhdr} % Fancy headers and footers
\usepackage{lipsum} % Insert dummy text
\usepackage{tcolorbox} % Create coloured boxes (e.g. the one for the key-words)

\input{../Configuration_files/config}
\makeatletter
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
Main Work
\end_layout

\begin_layout Standard
The main goal of this thesis work has been to push even more the Time-to-Digital
 Converter performances, obtaining a drag-and-drop, tunable IP-Core, compatible
 with Xilinx Ultrascale (20 nm) and Ultrascale+ (16 nm) FPGAs.
 The migration to a new technology, characterized by an improved scaling
 than Xilinx 7-Series, has allowed pushing the frequency of the clock involved
 in the time measurements, resulting in a TDC with faster Measure Rate,
 lower Dead-Time, and better Resolution (see Eqution 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:TDL resolution"
plural "false"
caps "false"
noprefix "false"

\end_inset

).
 The scaling is also beneficial for the 
\begin_inset Quotes eld
\end_inset

ultra-bins
\begin_inset Quotes erd
\end_inset

 phenomenon since they are faster than their 7-Series counterparts; this
 results in an overall improvement of the measurements' single-shot precision.
 Firstly, let's briefly describe the blocks composing the main core of the
 older version of the TDC, which was implemented on Xilinx 7-Series technology;
 then, each one of them will be described in detail, highlighting the improvemen
ts done in this thesis work.
\end_layout

\begin_layout Subsection
Main blocks of the TDC
\end_layout

\begin_layout Standard
The old version of the Time-To-Digital Converter, implemented at the Digital
 Electronics Laboratory (DigiLAB) at Politecnico di Milano, has been implemented
 on Xilinx 7-Series (28 nm) Artix-7 FPGA, and it is a Tapped Delay-Line
 based TDC (TDL-TDC).
 Besides, it is a TIMESTAMP-type TDC, thus being composed of as many channels
 as the number of physical events to detect.
 As described in Paragraph 1.2, by considering two of the channels composing
 the TDC, the time distance between the two respective input signals is
 computed as the difference between the timestamps provided by each channel.
 The processing chain inside each channel starts with the Virtual Tapped
 Delay-Line (V-TDL), which provides a thermometric code in output, representing
 the Fine part of the timestamp, as explained in Paragraph 2.1.
 The thermometric code is then converted into a binary one by a Decoder.
 Once the binary code of the Fine measurement is obtained, Nutt-Interpolation
 is implemented by a module called Coarse Extension Core (CEC).
 This block attaches the Fine part to a Coarse part, the latter provided
 by a Coarse Counter sub-module that can be internal to the CEC or external.
 Furthermore, the CEC performs a Clock-Domain Crossing (CDC), meaning that
 the system goes from a faster clock to a slower one, allowing the data
 processing on all the following blocks to respect all the timing constraints
 of the system.
 The following block in the processing chain is the Calibrator, in charge
 of performing a bin-by-bin calibration to compensate PVT variations of
 the TDL's taps, as explained in Paragraph 2.3.
 Finally, an Overflow Counter further extends the FSR of the TDC by counting
 the overflows of the Coarse Counter present in the CEC.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schematic-of-the"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows a block diagram of the TDC, composed of all the aforementioned modules.
 Since this thesis work consisted in modifying the internal blocks, the
 macroscopic structure of the TDC, reported in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Schematic-of-the"
plural "false"
caps "false"
noprefix "false"

\end_inset

, has been maintained.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../2.State-of-the-Art/images/oldtdc.png
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Schematic of the structure of the older version of the TDC.
\begin_inset CommandInset label
LatexCommand label
name "fig:Schematic-of-the"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The communication between all the blocks is in the AXI4Stream protocol.
 This protocol consists of a flux of data from the output of a module, called
 “master”, to the input of the following one, called “slave”.
 The main signals of the AXI4Stream protocol are:
\end_layout

\begin_layout Itemize
TDATA, which is effectively the data to be sent;
\end_layout

\begin_layout Itemize
TVALID, which is a flag produced by the master, telling the slave that the
 incoming data is valid;
\end_layout

\begin_layout Itemize
TREADY, which is a flag produced by the slave, which tells the master that
 the module is ready to accept the data.
\end_layout

\begin_layout Standard
The AXI4Stream protocol relies on the concept of Handshake between TVALID
 and TREADY.
 A Handshake transaction is reported in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AXI4Stream-protocol."
plural "false"
caps "false"
noprefix "false"

\end_inset

, and takes place only when both TVALID and TREADY are equal to '1'.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/axi4stream.png
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AXI4Stream protocol.
\begin_inset CommandInset label
LatexCommand label
name "fig:AXI4Stream-protocol."

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
All the presented blocks are connected inside a hierarchical IP-Core, which
 is nothing but a channel of the TDC.
 Since we are usually interested in the relative time distance between physical
 events, the TDC will be characterized by more than one channel, each one
 providing the respective timestamp with respect to a common absolute time
 reference (i.e., the power-on instant of the device).
 Then, an external module called 
\begin_inset Quotes eld
\end_inset

Histogrammer
\begin_inset Quotes erd
\end_inset

 will perform a repeated set of measurements of the time difference between
 two of those channels, and it will thus provide a Gaussian distribution
 characterized by a mean value and a certain standard deviation.
 As described in Paragraph 1.3.3, the standard deviation will be used as the
 index of the single-shot precision of the TDC.
 
\end_layout

\begin_layout Subsection
Virtual Tapped Delay-Line (V-TDL)
\end_layout

\begin_layout Subsubsection
Old Version
\end_layout

\begin_layout Standard
This module is in charge of performing the Fine measurement of the timestamp.
 Let's see in detail how it is structured.
 As explained in Paragraph 1.5.3, the TDL is nothing but a sequence of buffers
 connected in series, and it has been obtained by cascading Xilinx's CARRY
 primitives.
 In the old version of the V-TDL, implemented on the Xilinx 7-Series (X7S)
 technology node, the elementary block used to create the chain structure
 is the CARRY4 primitive.
 
\begin_inset CommandInset citation
LatexCommand cite
key "XlinxUG474"
literal "false"

\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CARRY4-primitive-truth"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the internal structure of the CARRY4 primitive.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/Carry4_internal.PNG
	width 40text%

\end_inset


\begin_inset Graphics
	filename images/Carry4.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CARRY4 primitive structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:CARRY4-primitive-truth"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see, the CARRY4 primitive has two 4-bit outputs, the first being
 the CO port (i.e., the set of the output carry-signals), the second being
 the O port (i.e., the set of the XOR-outputs, representing the result of
 the sum).
 The four stages composing the CARRY4 primitive are nothing but four buffers
 (or taps) composing the TDL, cascaded thanks to the carry-out (CO) connections.
 Therefore, according to the number of taps required to compose the entire
 TDL, a certain number of CARRY4 primitives will be cascaded by connecting
 the carry-output of the fourth stage (i.e., CO(3)) of the previous primitive
 to the carry-input port (CI) of the following primitive.
 The asynchronous input event to be measured (i.e., the START signal) is connected
 to the carry-input port (CI) of the first primitive, and the multiplexer's
 selection signal (S) of each stage is set to propagate the signal on CI
 along all the stages.
 In this way, as soon as the asynchronous input switches from '0' to '1',
 propagation of 
\begin_inset Quotes eld
\end_inset

ones
\begin_inset Quotes erd
\end_inset

 takes place along the carry-chain, thus causing a '0'
\begin_inset Formula $\rightarrow$
\end_inset

'1' transition on each CO output (or a '1'
\begin_inset Formula $\rightarrow$
\end_inset

'0' transition on each O output, which is nothing but the inverted and delayed
 CO output) with different propagation delays.
 Each output (CO or O) of the chain is then connected to the D-input of
 a flip-flop (FF), used to sample the logic value of that specific tap,
 when the STOP signal occurs.
 The STOP signal is a user-chosen rising-edge of a clock signal at 400 MHz
 frequency; when the STOP signal occurs, a snapshot of the TDL state (i.e.,
 the number of buffers hit by the propagation of 
\begin_inset Quotes eld
\end_inset

ones
\begin_inset Quotes erd
\end_inset

 up to that moment) is taken and, therefore, a thermometric code is generated
 at the output of the chain of FFs.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CARRY4-based-Tapped-Delay-Line"
plural "false"
caps "false"
noprefix "false"

\end_inset

 graphically shows the structure of the TDL.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/carry-tdl.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CARRY4-based Tapped Delay-Line structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:CARRY4-based-Tapped-Delay-Line"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

In the following description, the words written in italic capital letters
 refer to the Hardware Description Language (HDL) generics used in the code,
 which are settable by the IP-Core's Graphical User Interface (GUI).
 This allows having a highly-tunable TDL.
 As explained in Paragraph 2.2, if a SuperWU Sub-Interpolation is performed,
 a Virtual Tapped Delay-Line (V-TDL), composed of more TDLs in parallel,
 is obtained.
 The V-TDL is composed of 
\shape italic
NUMBER_OF_TDL
\shape default
 TDLs in parallel, where each one is 
\shape italic
NUM_TAP_TDL
\shape default
-taps long.
 This results in a V-TDL composed of 
\shape italic
NUMBER_OF_TDL
\begin_inset Formula $\cdot$
\end_inset

NUM_TAP_TDL
\shape default
 
\begin_inset Quotes eld
\end_inset

virtual
\begin_inset Quotes erd
\end_inset

 taps.
 Moreover, thanks to the Sub-Interpolation, the propagation delay of the
 Virtual Tapped Delay-Line is, on average, NUMBER_OF_TDL times faster than
 the propagation delay of the real, single, TDL.
 Then, 
\shape italic
BIT_SMP_TDL
\shape default
 FFs will be placed at the output of the TDL.
 Since 
\shape italic
BIT_SMP_TDL
\shape default

\begin_inset Formula $\leq$
\end_inset


\shape italic
NUM_TAP_TDL
\shape default
 holds, it is possible either to sample the output of each buffer, by placing
 a number of FFs equal to the number of taps, or to sample just a decimated
 number of taps, by placing less FFs than buffers.
 In the latter case, hardware resources are saved, but a thermometric code
 composed of a lower number of bits is generated; hence, the resolution
 (LSB) is worsened.
 The sampling of the V-TDL is also managed by the generics 
\shape italic
TYPE_TDL_i
\shape default
 and 
\shape italic
OFFSET_TAP_TDL_i
\shape default
, where 
\shape italic
i
\shape default
 is a value between 0 and 
\shape italic
NUMBER_OF_TDL
\shape default
 indicating which physical TDL we are referring to.
 With 
\shape italic
TYPE_TDL_i
\shape default
 it is possible to choose which taps, CO or O, of the CARRY4 primitive we
 want to sample, for the 
\shape italic
i
\shape default
-th TDL.
 Then, if we are in the decimated case (i.e.,
\shape italic
 BIT_SMP_TDL
\begin_inset Formula $<$
\end_inset

NUM_TAP_TDL
\shape default
), with the generic 
\shape italic
OFFSET_TAP_TDL_i
\shape default
 it is possible to set an initial offset in the sampling of the chains,
 which means that the first FF of the 
\shape italic
i
\shape default
-th TDL is placed after 
\shape italic
OFFSET_TAP_TDL_i
\shape default
 taps rather than on the first one.
 The concept of decimation and offset is exemplified in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Concept-of-decimated"
plural "false"
caps "false"
noprefix "false"

\end_inset

, where we have a certain 
\shape italic
NUM_TAP_TDL
\shape default
 with 
\shape italic
BIT_SMP_TDL
\shape default
 = 
\shape italic
NUM_TAP_TDL/2
\shape default
, and the two different cases with 
\shape italic
OFFSET_TAP_TDL
\shape default
 = 0 (at the top) and 
\shape italic
OFFSET_TAP_TDL
\shape default
 = 1 (at the bottom).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/offset.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Concept of decimated sampling and offset.
\begin_inset CommandInset label
LatexCommand label
name "fig:Concept-of-decimated"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
In Paragraph 1.5.3, we have said that the STOP signal, which saves the output
 of the TDL in the FFs, is the rising clock-edge following the arrival of
 the START event.
 That was a general case, whereas the TDL implemented in our laboratory
 relies on a 
\begin_inset Quotes eld
\end_inset

VALID
\begin_inset Quotes erd
\end_inset

 mechanism that allows the user to choose which rising-edge will perform
 the sampling.
 We are talking about the already-mentioned TVALID signal of the AXI4Stream
 protocol.
 It is up to the user to decide the TDL's tap where the TVALID signal will
 be asserted, thus being able to center the clock period in that precise
 spot of the TDL.
 As soon as the selected tap makes a '0'
\begin_inset Formula $\rightarrow$
\end_inset

'1' transition (i.e., it gets crossed by the input asynchronous signal), the
 TVALID signal of the AXI4Stream protocol is asserted, and TDATA is sent
 in output.
 If the user decides to select the TVALID assertion on one of the first
 taps, it is equivalent to centering the clock period at the beginning of
 the TDL; therefore, the output TDATA (i.e., the thermometric code), will
 be composed of just few 
\begin_inset Quotes eld
\end_inset

ones
\begin_inset Quotes erd
\end_inset

, since the asynchronous input signal still has not propagated that much
 along the chain.
 On the other hand, if the user selects the TVALID assertion on the last
 few taps, the clock period will be centered at the very end of the buffer-chain
, and the thermometric code will be composed mostly of 
\begin_inset Quotes eld
\end_inset

ones
\begin_inset Quotes erd
\end_inset

 since the input signal has traveled as far as these last taps.
 The same reasoning applies to all the other intermediate positions.
 To further improve the TVALID selection, a PRE-TDL has been introduced
 before each TDL.
 The PRE-TDL is composed of 
\shape italic
NUM_TAP_PRE_TDL
\shape default
 taps, of which just 
\shape italic
BIT_SMP_PRE_TDL
\shape default
 taps are sampled.
 The PRE-TDL is not used for measuring the incoming signal, but just to
 anticipate the acquisition of the TVALID before the acquisition of the
 asynchronous input signal.
 Indeed, if we choose the TVALID assertion on PRE-TDL's tap, the thermometric
 code, given by the actual TDL only, would have very few 
\begin_inset Quotes eld
\end_inset

ones
\begin_inset Quotes erd
\end_inset

 since the input signal would have traveled just on the PRE-TDL and on the
 very first TDL's taps.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Valid-mechanism-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the concepts just explained, highlighting the different positions
 of the clock period with respect to the TDL.
 The “VALID” mechanism allows the TVALID signal to have a high logical value
 for just one clock period, whose rising-edge is nothing but the STOP signal.
 The great usefulness given by the “VALID” mechanism is being able to center
 the period of the clock signal in a convenient spot of the TDL, without
 “ultra-bins” and therefore capable of providing highly-precise measurements.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/valid.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Valid mechanism of the TDL and role of the PRE-TDL.
\begin_inset CommandInset label
LatexCommand label
name "fig:Valid-mechanism-of"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The TVALID selection is performed in two different modes, based on the generic
 
\shape italic
DEBUG_MODE
\shape default
.
 If 
\shape italic
DEBUG_MODE = 
\shape default
FALSE, the 
\begin_inset Quotes eld
\end_inset

VALID
\begin_inset Quotes erd
\end_inset

 position is statically chosen by the generic 
\shape italic
VALID_POSITION_TAP_INIT, 
\shape default
which is a value between 0 and 
\shape italic
BIT_SMP_PRE_TDL
\shape default
+
\shape italic
BIT_SMP_TDL
\shape default
-1.
 Conversely, if 
\shape italic
DEBUG_MODE
\shape default
 = TRUE, the 
\begin_inset Quotes eld
\end_inset

VALID
\begin_inset Quotes erd
\end_inset

 position is chosen at run-time, by Port.
 In this case, we can select just a few of the 
\shape italic
BIT_SMP_PRE_TDL
\shape default
+
\shape italic
BIT_SMP_TDL
\shape default
 sampled taps from which we could extract the TVALID, and it is done thanks
 to the generics 
\shape italic
MIN_VALID_TAP_POS
\shape default
, 
\shape italic
MAX_VALID_TAP_POS
\shape default
, and 
\shape italic
STEP_VALID_TAP_POS
\shape default
.
 With these generics, we choose just some FFs along the chain from which
 we can select the TVALID, thus performing a decimation and avoiding using
 large multiplexers that may reduce the timing performance.
 Among these few FFs, the final position is selected with the Port 
\begin_inset Quotes eld
\end_inset

ValidPositionTap
\begin_inset Quotes erd
\end_inset

.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Valid-selection-in"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows, with an example, the explained working principle in 
\shape italic
DEBUG_MODE
\shape default
 = TRUE and with 
\shape italic
MIN_VALID_TAP_POS
\shape default
 = 0, 
\shape italic
MAX_VALID_TAP_POS
\shape default
 = 4,
\shape italic
 STEP_VALID_TAP_POS
\shape default
 = 2.
 Since, if we use the SuperWU Sub-Interpolation algorithm, there are more
 TDLs in parallel, we must select one single TDL among them in which the
 aforementioned "VALID" selection process is performed.
 This is done statically by the generic 
\shape italic
VALID_NUMBER_OF_TDL_INIT
\shape default
 if 
\shape italic
DEBUG_MODE
\shape default
 = FALSE, or by the Port 
\begin_inset Quotes eld
\end_inset

ValidNumberOfTDL
\begin_inset Quotes erd
\end_inset

 if 
\shape italic
DEBUG_MODE
\shape default
 = TRUE.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/valid_sel.png
	width 40text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Valid selection in 
\shape italic
DEBUG_MODE
\shape default
 = TRUE.
\begin_inset CommandInset label
LatexCommand label
name "fig:Valid-selection-in"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, there is the possibility of just simulating the TDL rather than
 implementing it, thanks to the generic 
\shape italic
SIM_VS_IMP
\shape default
.
 If
\shape italic
 SIM_VS_IMP = 
\shape default

\begin_inset Quotes eld
\end_inset

SIM
\begin_inset Quotes erd
\end_inset

, the TDL is not physically implemented with the CARRY4 primitive, but a
 fictitious buffer-chain is created just for a test-bench scope.
 The simulated delays of the fictitious buffers are imported from two .txt
 files, 
\shape italic
FILE_PATH_NAME_O_DELAY
\shape default
 and 
\shape italic
FILE_PATH_NAME_CO_DELAY,
\shape default
 containing their estimated delays
\begin_inset Note Note
status open

\begin_layout Plain Layout
revisione personale fino a qui
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
New Version
\end_layout

\begin_layout Standard
In this thesis work, the portability of the Virtual Tapped Delay-Line has
 been improved, making it compatible also with 20-nm Xilinx Ultrascale (XUS)
 and 16-nm Ultrascale+ technology nodes.
 These are more scaled technologies with respect to 28-nm Xilinx 7-Series
 (X7S), leading to a lower power consumption and better performances such
 as an increased measure rate, a better resolution, lower ultra-bins and,
 as a consequence, a better single-shot precision for the TDC.
 Thanks to the generic 
\shape italic
XUS_VS_X7S 
\shape default
in the IP-Core GUI
\shape italic
, 
\shape default
the technology node of the TDL that will be placed on the FPGA's fabric,
 can be chosen by the user in the instantiation stage, improving even more
 the portability of this structure on different systems.
 We already talked about the TDL structure for Xilinx 7-Series technology;
 let's now focus on the Ultrascale/Ultrascale+ version.
 
\end_layout

\begin_layout Paragraph
Major differences between 7-Series and Ultrascale
\end_layout

\begin_layout Standard
The new version of the TDC has been fully implemented and tested on a Kintex
 Ultrascale FPGA, which has up to 40% lower power consumption with respect
 to the previous generation.
 Let's briefly describe the other major differences between the two technologies
, other than the power consumption.
 The other main differences are structure-related, thus involving Configural
 Logic Blocks (CLBs) and slices 
\begin_inset CommandInset citation
LatexCommand cite
key "XlinxUG474"
literal "false"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "XILINX_ULTRASCALE"
literal "false"

\end_inset

.
 The CLBs are the main resources to implement general-purpose combinatorial
 and sequential circuits in FPGA, while the slices are the internal parts
 of the CLBs.
 The slices and their CLBs are arranged in columns throughout the device,
 and they can easily connect to each other in order to create larger functions.
 Both 7-Series and Ultrascale CLBs provide:
\end_layout

\begin_layout Itemize
Real 6-input look-up table (LUT) technology;
\end_layout

\begin_layout Itemize
Dual 5-input LUT (LUT5) option;
\end_layout

\begin_layout Itemize
Distributed Memory and Shift Register Logic capability;
\end_layout

\begin_layout Itemize
Wide multiplexers (MUXes) for efficient utilization;
\end_layout

\begin_layout Itemize
Dedicated high-speed carry logic for arithmetic functions;
\end_layout

\begin_layout Standard
The Ultrascale CLB has also dedicated storage elements that can be configured
 as flip-flops (FFs) or latches with flexible control signals.
\end_layout

\begin_layout Standard
The main structural difference between 7-Series and Ultrascale is internal
 to the CLB, thus residing on the Slices.
 The main differences inside a single CLB are reported in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:CLB-differences-between"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Differences in a single CLB between Xilinx 7-Series and Xilinx Ultrascale
 technology nodes.
\begin_inset CommandInset label
LatexCommand label
name "tab:CLB-differences-between"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Features
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
X7S
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
XUS
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of slices
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of 6-input LUTs in a single slice
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Number of FFs in a single slice
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As we can see, in Xilinx Ultrascale technology, two independent slices are
 now combined in a single, bigger slice, in order to have a better efficiency
 in the routing on the FPGA's fabric.
 The carry logic, in particular, is extended from 4 bits to 8 bits, achieving
 better routing and faster arithmetic functions.
 One single 8-bit carry chain is contained in a CLB.
 This is the reason why Xilinx Ultrascale uses the CARRY8 primitive to perform
 arithmetic functions, rather than the CARRY4 of the previous generation.
 The structure of the CARRY8 primitive is reported in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CARRY8-primitive-structure."
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/carry_8.png
	width 40text%

\end_inset


\begin_inset Graphics
	filename images/carry8.png
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CARRY8 primitive structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:CARRY8-primitive-structure."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that the CARRY8 primitive can be configured either as a single
 8-bit carry chain or as two independent 4-bit carry chains.
 The former option has been adopted in this thesis work.
\end_layout

\begin_layout Paragraph
XUS-TDL structure
\end_layout

\begin_layout Standard
In analogy with the X7S version of the TDL, we can see that here a single
 CARRY8 implements 8 buffers (taps) of the Tapped Delay-Line, and as before,
 more carry chains are cascaded connecting the last carry-out (CO(7)) of
 the previous primitive with the carry-in (CI) of the following one.
 The output of the buffers can be taken either from the sum output (O) or
 from the carry output (CO) by choosing the value of the generic 
\shape italic
TYPE_TDL
\shape default
 from the IP-Core's GUI, as before.
 The structure of the TDL is reported in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:CARRY8-based-Tapped-Delay-Line"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/carry8_tdl.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CARRY8-based Tapped Delay-Line structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:CARRY8-based-Tapped-Delay-Line"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Concerning the sampling process, with the decimation of the flip-flops along
 the chain and the initial offset, all has been mantained as before.
 Also the valid mechanism, to choose the clock period in which the snapshot
 of the TDL is carried out, is the same as in the older version; the clock
 sampling the TDL has instead been pushed to 500 MHz, thanks to the possibilitie
s given by the better scaling of the UltraScale technological node with
 respect to 7-Series, thus improving the measure rate and the dead-time
 of the TDC.
 
\end_layout

\begin_layout Standard
The other major change to the Virtual Tapped Delay-Line introduced in this
 thesis work, is the possibility to instantiate also Digital Signal Processor
 (DSP)-based TDLs, in parallel to the carry-based ones.
 This is possible thanks to the two new generics 
\shape italic
NUMBER_OF_CARRY_CHAINS
\shape default
 and 
\shape italic
NUMBER_OF_DSP_CHAINS
\shape default
 introduced in substitution of the old 
\shape italic
NUMBER_OF_TDL
\shape default
.
 The SuperWU sub-interpolation algorithm now creates a Virtual Tapped Delay-Line
 made by 
\shape italic
NUMBER_OF_CARRY_CHAINS
\shape default
 +
\shape italic
 NUMBER_OF_DSP_CHAINS
\shape default
 TDLs in parallel, where each one is 
\shape italic
NUM_TAP_PRE_TDL
\shape default
 +
\shape italic
 NUM_TAP_TDL
\shape default
 long.
 This adds even more versatility to the IP-Core, indeed, it allows to implement
 a V-TDL either made only by carry-based TDLs (if 
\shape italic
NUMBER_OF_DSP_CHAINS
\shape default
=0), or by only DSP-based TDLs (if 
\shape italic
NUMBER_OF_CARRY_CHAINS
\shape default
=0), or by a combination of them (if 
\shape italic
NUMBER_OF_CARRY_CHAINS
\shape default

\begin_inset Formula $\neq$
\end_inset

0, 
\shape italic
NUMBER_OF_DSP_CHAINS
\shape default

\begin_inset Formula $\neq$
\end_inset

0).
 We will see later what is the utility of a DSP-based TDL, and why the sub-inter
polation that combines both types of TDL is the most powerful one.
 But before, let's present the Xilinx Digital Signal Processor (DSP).
\end_layout

\begin_layout Paragraph
Xilinx Digital Signal Processor (DSP)
\end_layout

\begin_layout Standard
FPGAs are suitable for digital signal processing (DSP) applications because
 they can implement custom, fully parallel algorithms.
 The main operation performed by DSPs is MAC (Multiply and Accumulate),
 which consists in the calculation of the product between two numbers, and
 its addition in the accumulator.
 In hardware it is implemented as a multiplier followed by an adder and
 a register, but its implementation on FPGA employs a lot of resources,
 and has a low processing speed.
 For this reason, Xilinx decided to place dedicated DSP blocks on the FPGA
 fabric.
\end_layout

\begin_layout Standard
Xilinx 7-Series technology uses the DSP48E1 slice as DSP block 
\begin_inset CommandInset citation
LatexCommand cite
key "XILINX_7_SERIES"
literal "false"

\end_inset

, while Xilinx Ultrascale/Ultrascale+ uses the DSP48E2 slice 
\begin_inset CommandInset citation
LatexCommand cite
key "XUS_DSP"
literal "false"

\end_inset

.
 Since there are minor differences between the two DSP's technologies, and
 they are not a relevant topic of this thesis, from now on we will refer
 just to the DSP48E2 to describe both.
 The DSP48E2 slice consists of a 27-bit pre-adder, a 27 x 18 multiplier
 and, a flexible 48-bit Arithmetic Logic Unit (ALU) that serves as a post-adder/
subtracter, accumulator, or logic unit (see Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:DSP48E2-structure."
plural "false"
caps "false"
noprefix "false"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/DSP48E2.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
DSP48E2 structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:DSP48E2-structure."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see from Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:DSP48E2-structure."
plural "false"
caps "false"
noprefix "false"

\end_inset

 that there are four direct inputs (A, B, C, D) and a 48-bit wide direct
 output (P), which is the result of the operation performed by the ALU.
 An input carry and an output one are also present, along with an output
 port for pattern detection and the output of a XOR gate.
 Furthermore, 5 input (ACIN, BCIN, PCIN, CARRYCASCIN, MULTSIGNIN) and output
 ports (ACOUT, BCOUT, PCOUT, CARRYCASCOUT, MULTSIGNOUT), with the function
 of cascading more DSP slices, are present.
 All the remaining inputs are control signals:
\end_layout

\begin_layout Itemize
ALUMODE: it controls the operation to be performed by the ALU, which is
 either a sum, a subtraction, or a logic operation.
\end_layout

\begin_layout Itemize
CARRYINSEL: it decides whether the direct carry-in or the cascade one is
 fed to the ALU.
\end_layout

\begin_layout Itemize
OPMODE: it contains fields for W, X, Y, and Z multiplexer selects.
 So, basically, this signal decides which input signals are fed to the ALU,
 making them nothing but the factors of the operation decided by ALUMODE.
\end_layout

\begin_layout Itemize
INMODE: it controls the functionality of the pre-adder.
\end_layout

\begin_layout Standard
These control signals require a specific bit-mask to perform all the different
 functionalities, as can be seen in the data-sheet (User Guide) 
\begin_inset CommandInset citation
LatexCommand cite
key "XUS_DSP"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Finally, it is worth saying that the DSP48E2 has three different working
 modes.
 Indeed, thanks to the Single-Instruction-Multiple-Data (SIMD) mode, the
 48-bit ALU (the first, default, working mode) also supports dual 24-bit
 (the second working mode) or quad 12-bit (the third working mode) arithmetic
 operations.
 Based on the experimental results that will be shown later, the dual 24-bit
 SIMD mode has been used in this thesis work, thus having a single 48-bit
 ALU that works as two, independent, 24-bit ALUs in parallel.
 
\end_layout

\begin_layout Paragraph
DSP-based TDL
\end_layout

\begin_layout Standard
The propagation mechanism of the asynchronous input signal (i.e.
 START signal) along the DSP's output bits, representing the taps of the
 TDL, is based on the subtraction operation performed by the ALU.
 Let's see more in detail the ports and the control signals involved.
 The dual A and B register, along with the pre-adder and the multiplier,
 are not involved in this implementation, thus they are bypassed by all
 the signals, and the D input and the INMODE control is not used.
 The ALUMODE signal is set such that the ALU performs the following operation:
\begin_inset Formula 
\begin{equation}
P=Z-(W+X+Y+CIN)\label{eq:alu}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
where CIN is selected by CARRYINSEL to be the direct CARRYIN signal, imposed
 equal to zero; and Z, W, X, Y are the input signals, multiplexed by OPMODE.
 The selection is such that:
\end_layout

\begin_layout Itemize
Z feeds the C input signal to the ALU;
\end_layout

\begin_layout Itemize
W feeds a vector of zeroes to the ALU;
\end_layout

\begin_layout Itemize
X feeds the concatenated A and B input signals (A:B) to the ALU; 
\end_layout

\begin_layout Itemize
Y feeds a vector of zeroes to the ALU;
\end_layout

\begin_layout Standard
The A:B vector is the one containing the asynchronous input signal (AsyncInput)
 the TDC has to measure, while to the C port is assigned a vector of zeroes.
\end_layout

\begin_layout Standard
The ALU, P, C, A:B and the vectors of zeroes are all 48-bit wide, but, since
 in this work the DSP is used in dual 24-bit SIMD mode, in reality is like
 having a single DSP slice containing two independent ALUs working in parallel,
 where each one of them has 24-bit wide P, C, A:B signals, and 24-bit wide
 vectors of zeroes.
\end_layout

\begin_layout Standard
To form a long DSP-based TDL, more DSP slices have to be cascaded, and this
 is done by connecting the ACOUT and BCOUT ports of the previous slice to
 ACIN and BCIN of the following one.
 Therefore, the AsyncInput is connected to the direct A and B input ports
 just on the first DSP block and, on the following ones, it just propagates
 in the cascade inputs ACIN and ACOUT, and the direct A and B inputs are
 not used anymore.
 Since A is 30-bit wide and B is 18-bit wide, the AsyncInput signal must
 be linked both to bit 0 of B and to bit 6 of A, in order to have the logical
 value of our signal of interest on the least-significant bit of each 24-bit
 half of the A:B vector.
 In this way, in both the two 24-bit ALUs, the decimal value of the factor
 coming from the X multiplexer is equal to 0 when AsyncInput = 0, and it
 switches to 1 as soon as AsyncInput makes a transition form 0 to 1.
 This data assignment is better clarified in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:AsyncInput-connection-to"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/asyncinput.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
AsyncInput connection to A and B ports of the DSP slice.
\begin_inset CommandInset label
LatexCommand label
name "fig:AsyncInput-connection-to"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, at the P output, the internal register of the DSP48E2 is used to
 sample the TDL; therefore, external flip-flops are not required, as it
 was in the carry-based TDL.
 We can see in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Internal-operation-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

 all the internal resources and signals involved in the setup of the DSP
 slice.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/internal_dsp.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Internal operation of the DSP48E2 block.
\begin_inset CommandInset label
LatexCommand label
name "fig:Internal-operation-of"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
By taking Equation 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alu"
plural "false"
caps "false"
noprefix "false"

\end_inset

, and substituting the values assigned to all the signals in the instantiation
 stage of the DSP48E2, we obtain the following equation:
\begin_inset Formula 
\begin{equation}
P=0-(0+AsyncInput+0+0)\label{eq:mid-formula}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
which leads to the simple subtraction:
\begin_inset Formula 
\begin{equation}
P=0-AsyncInput\label{eq:sub-formula}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Therefore, until AsyncInput stays at 0, P is a 24-bit wide vector of zeroes;
 then, as soon as AsyncInput transits from 0 to 1, an underflow takes place,
 and there is a propagation of 
\begin_inset Quotes eld
\end_inset

1
\begin_inset Quotes erd
\end_inset

 from the least-significant bit to the most-significant bit of the P result.
 This behavior is the same as in the carry-based TDL: the bits of the P
 output are the taps of the TDL, and the underflow-carry takes a certain
 propagation delay to cross each one of them.
 
\end_layout

\begin_layout Standard
The DSP-based TDL relies on the same Valid mechanism of the carry-based
 counterpart, and the clock period selected by the valid assertion is the
 STOP signal that takes a snapshot of the state of the TDL.
 Since a single DSP48E2 is used in dual 24-bit mode, two thermometric codes
 are generated in parallel, as final output.
 We can better see the propagation mechanism in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Propagation-mechanism-along"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/dsp-propagation.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Propagation mechanism along the DSP-based TDL.
\begin_inset CommandInset label
LatexCommand label
name "fig:Propagation-mechanism-along"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The generic 
\shape italic
NUMBER_OF_DSP_CHAINS 
\shape default
decides how many 
\begin_inset Quotes eld
\end_inset

active
\begin_inset Quotes erd
\end_inset

 ALUs are performing the subtraction operation in parallel.
 For example, if 
\shape italic
NUMBER_OF_DSP_CHAINS
\shape default
 = 1 or 
\shape italic
NUMBER_OF_DSP_CHAINS
\shape default
 = 2, in both cases the TDL is composed by a single DSP-chain.
 But, keeping in mind that each DSP48E2 is used in dual 24-bit SIMD mode,
 the difference is that: in the second case, both the 24-bit ALUs perform
 the operation, and two thermometric codes are generated in output; instead,
 in the first case, just one of the two ALUs is involved in the operation,
 and one single thermometric code is produced.
 Since, in both cases, the same amount of DSP resources is exploited and
 since, thanks to the sub-interpolation, having two thermometric codes is
 more beneficial than having just a single one, choosing an even number
 for 
\shape italic
NUMBER_OF_DSP_CHAINS 
\shape default
is always the more convenient choice
\shape italic
.
\end_layout

\begin_layout Standard
Moreover, the generic 
\shape italic
XUS_VS_X7S 
\shape default
allows
\shape italic
 
\shape default
to choose the technology node also for the DSP slice, as it is for the carry
 primitive.
 If 
\shape italic
XUS_VS_X7S = 
\shape default

\begin_inset Quotes eld
\end_inset

X7S
\begin_inset Quotes erd
\end_inset

, only DSP48E1 primitives are instantiated; if instead 
\shape italic
XUS_VS_X7S = 
\shape default

\begin_inset Quotes eld
\end_inset

XUS
\begin_inset Quotes erd
\end_inset

, only DSP48E2 primitives are implemented.
 
\end_layout

\begin_layout Paragraph
Advantages and drawbacks of the DSP-based TDL
\end_layout

\begin_layout Standard
One great advantage of this type of Tapped Delay-Line (TDL) is that the
 taps (bins) of the DSP slice are characterized by a tiny propagation delay,
 in the order of very few picoseconds (ps), thus allowing a very fast propagatio
n of the input signal along the chain.
 However, the cascade path from one DSP slice to another introduces a huge
 propagation delay and therefore the presence of a very high ultra-bin in
 the chain.
 The recurring presence of ultra-bins along the DSP-based TDL is the main
 drawback of this architecture, since, as explained earlier, it worsens
 the single-shot precision of the Time-to-Digital Converter (TDC).
 
\end_layout

\begin_layout Standard
The main reason which led to use DSPs as main blocks to create a TDL is
 that, exploiting this type of resource makes possible to build a more compact
 structure because it avoids long carry chains hindering the routing across
 different regions of the FPGA, also leading to relax the hardware utilization.
 Indeed, the sampling of the Tapped Delay-Line is made by the P-register
 integrated in the DSP itself, thus not requiring to use the flip-flops
 (FFs) present in the FPGA fabric, as it was in the carry-based approach.
 
\end_layout

\begin_layout Standard
As we will see later, when the obtained experimental results will be shown,
 the combination of the carry-based TDL and the DSP-based TDL creates an
 
\begin_inset Quotes eld
\end_inset

hybrid
\begin_inset Quotes erd
\end_inset

 Virtual Tapped Delay-Line (V-TDL) which, thanks to the SuperWU sub-interpolatio
n algorithm, allows to exploit the best features of both the two architectures,
 and to achieve an overall better single-shot precision with respect to
 the fully carry-based approach.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Virtual-Tapped-Delay-Line"
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be seen the IP-Core package and its generics.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/V-TDL_IP.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Virtual Tapped Delay-Line (V-TDL) IP-Core.
\begin_inset CommandInset label
LatexCommand label
name "fig:Virtual-Tapped-Delay-Line"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Decoder
\end_layout

\begin_layout Standard
This module hasn't been modified in this thesis work, therefore, its unique
 version will be described in the following.
 The only difference is that, thanks to the migration to the Ultrascale
 technology node, the operating frequency of this module has been pushed
 from 400 MHz to 500 MHz, same as the V-TDL, thus increasing the measure
 rate of the system.
\end_layout

\begin_layout Standard
The Decoder has the task of converting the 
\shape italic
BIT_UNDECO
\shape default
-wide thermometric codes, one for each 
\begin_inset Quotes eld
\end_inset

real
\begin_inset Quotes erd
\end_inset

 Tapped Delay-Line (TDL) composing the V-TDL, into 
\shape italic
BIT_SUBINT
\shape default
-wide binary codes, representing the time information of the Fine part of
 the timestamp 
\begin_inset CommandInset citation
LatexCommand cite
key "4529581"
literal "false"

\end_inset

.
 
\end_layout

\begin_layout Standard
The conversion is done in pipeline, thanks to a Thermo-to-Binary (T2B) engine.
 Let's briefly describe the working principle of the T2B engine.
 First of all, it detects the position of the Rising or Falling edge of
 the input signal, and it does it by summing the '0's or the '1's of the
 thermometric data, respectively.
 Then, by means of a pipelined tree structure, it transforms the thermometric
 code into a binary one, by summing all the '1's in the case of an input
 signal with rising edge sensitivity, or all the '0's in the case of a falling
 edge in the input signal.
 The following relation holds:
\begin_inset Formula 
\begin{equation}
BIT\_SUBINT=\log_{2}(BIT\_UNDECO)+1\label{eq:decoder_eq}
\end{equation}

\end_inset

 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Thermometric-to-Binary"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the mechanism just explained, in the simple case of a 4-bit wide
 thermometric code coming from the TDL, which thus gives a 3-bit wide output
 binary code.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thermometric code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Binary code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0001
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
001
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
010
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
011
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
100
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset

 
\begin_inset space \space{}
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Thermometric code
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Binary code
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
000
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1110
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
001
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
010
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
011
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
100
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Thermometric to Binary conversion in the case of an input signal with rising
 edge sensitivity (table on the left) and with falling edge sensitivity
 (table on the right).
\begin_inset CommandInset label
LatexCommand label
name "tab:Thermometric-to-Binary"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The Decoder has also the task of performing sub-interpolation, and it does
 it by summing all the binary codes provided by each one of the real TDLs,
 by means of a pipelined Tree Adder (TA).
 It is possible to dynamically choose the number of TDLs involved in the
 sub-interpolation by means of the so-called SubInterpolationMatrix.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Selection-of-the"
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the case of 3 TDLs in parallel, thus giving 8 possible combinations.
 Obviously, by sub-interpolating all three TDLs, the best resolution is
 achieved, according to the SuperWU algorithm.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SubInterpolationMatrix
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V-TDL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
001
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
011
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #1 + TDL #2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
101
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #1 + TDL #3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #2 + TDL #3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TDL #1 + TDL #2 + TDL #3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Selection of the TDLs to involve in the sub-interpolation, by means of the
 SubInterpolationMatrix.
\begin_inset CommandInset label
LatexCommand label
name "tab:Selection-of-the"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Coarse Extension Core (CEC)
\end_layout

\begin_layout Standard
The Coarse Extension Core is where the Nutt-Interpolation is carried out,
 i.e.
 the addition of the Coarse measure to the Fine one (computed by the previous
 modules) in order to break the trade-off between Resolution and FSR.
 A 
\shape italic
BIT_COARSE_CEC
\shape default
-wide Coarse Counter is in charge of counting the number of clock periods
 elapsed from the power-on instant of the system, up to the generation of
 the Fine measure, accomplished by the V-TDL.
 An overflow detection is also implemented, and it will be used by one of
 the following modules to extend even more the FSR, up to some days.
 This overflow detection is performed by a sub-module called TreeComparator,
 which works in pipeline, and compares the value of the Coarse-Counter with
 a reference value equal to:
\begin_inset Formula 
\begin{equation}
OVERFLOW\_REF=2^{BIT\_COARSE\_CEC}-1-NUM\_STAGES\label{eq:OVERFLOW_REF}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In this way, as soon as the Coarse-Counter reaches its maximum value 
\begin_inset Formula $(2^{BIT\_COARSE\_CEC}-1)$
\end_inset

, an overflow condition is reported.
 The subtraction of NUM_STAGES is required in order to take into account
 the delay introduced by the pipeline stages of the TreeComparator.
\end_layout

\begin_layout Standard
The data produced by the Coarse Extension Core module is composed by three
 fields, as shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Coarse-Extension-Core"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/CEC.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Coarse Extension Core data structure.
\begin_inset CommandInset label
LatexCommand label
name "fig:Coarse-Extension-Core"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The FINE_PART field contains the binary code representing the Fine measurement,
 performed by the previous modules; the COARSE_COUNTER field contains the
 number of clock cycles of the 500 MHz clock signal, elapsed from the power-on
 instant of the system; the FID field contains the information about the
 occurrence of an overflow in the Coarse-Counter.
 If FID = '1', no overflow happened, and the COARSE_COUNTER and the FINE
 fields contain their respective measurement information.
 If instead FID = '0', an overflow happened, and the other two fields will
 contain their older values, in order to signal that the measure is not
 valid.
\end_layout

\begin_layout Standard
The CEC also performs another fundamental action, being Clock Domain Crossing
 (CDC).
 Indeed, it contains a FIFO that allows to avoid loosing consecutive measurement
s and to manage correctly the case in which a valid measure and an overflow
 occur concurrently, and it is written and read using two different clocks
 signals.
 The write process in the FIFO is under the TDC_Clock domain, i.e.
 the 500 MHz clock feeding also the V-TDL and the Decoder, while the read
 process is done under the SYS_Clock domain, i.e.
 a 200 MHz clock feeding all the following module.
 Therefore, a passage from a very fast clock to a slower one is done, so
 to have all the following processing under more relaxed timing contraints
 and avoid timing errors.
 
\end_layout

\begin_layout Standard
This module is the same as in the older version of the TDC.
 The only difference is that it is now used with a different value of the
 generic 
\shape italic
BIT_COARSE_CEC, 
\shape default
from 8 to 4.
 This is done in order to improve even more the timing performance (i.e.
 the Worst Negative Slack of the system), indeed, this allows to have a
 narrower data, and thus a narrower FIFO, which is what really influences
 the timing in the CEC.
 Obviously, this causes to signal more overflows than before, but this will
 be managed by one of the following modules, as we will see later.
\end_layout

\begin_layout Subsection
Calibrator
\end_layout

\begin_layout Standard
This module is the same of the old TDC, and it is in charge of keeping track
 of the process, voltage and temperature (PVT) variations affecting each
 bin of the V-TDL, by means of the Calibration Table (CT) and the Characteristic
 Curve (CC).
 Its working principle is the following one: a set of random signals is
 sent to the V-TDL, which generates a certain number of thermometric codes
 that are then converted into binary values by the Decoder.
 The Calibrator then performs a Code Density Test (CDT), which consists
 of counting how many samples (i.e.
 the binary values provided by the Decoder) fall on each bin of the V-TDL,
 in the clock window (i.e.
 the STOP signal) selected by the already-described 
\begin_inset Quotes eld
\end_inset

valid
\begin_inset Quotes erd
\end_inset

 mechanism.
 Finally, at each bin is associated its propagation delay value in picoseconds,
 and the CT is obtained.
 This conversion, from 
\begin_inset Quotes eld
\end_inset

bin counts
\begin_inset Quotes erd
\end_inset

 to picoseconds, is done in this way: let's suppose that, in the selected
 clock window, 
\begin_inset Formula $N$
\end_inset

 bins of the V-TDL are involved, and let's call 
\begin_inset Formula $n_{X}$
\end_inset

 the number of samples counted on the 
\begin_inset Formula $x$
\end_inset

-th bin, where 
\begin_inset Formula $x=1,2,...,N.$
\end_inset

 The propagation delay of each bin is obtained with this proportionality:
\begin_inset Formula 
\begin{equation}
t_{X}=\frac{n_{X}}{\sum_{x=1}^{N}n_{X}}\cdot T_{CLK,ps}\ ,\ x=1,2,...,N\label{eq:CT}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Graphical-explanation-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

 graphically explains the procedure just described.
 It's clear that, if a bin captures a significant amount of events, it will
 be mapped at a particularly high propagation delay value, and thus, it
 will be nothing but the already-described 
\begin_inset Quotes eld
\end_inset

ultra-bin
\begin_inset Quotes erd
\end_inset

, responsible for worsening the single-shot precision of the TDC.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/CDT_CT.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Graphical explanation of how the Calibrator builds the CT.
\begin_inset CommandInset label
LatexCommand label
name "fig:Graphical-explanation-of"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the CT is obtained, it is integrated in order to obtain the Characteristic
 Curve (CC) of the TDC, thus representing, for each one of the 
\begin_inset Formula $N$
\end_inset

 bins, the total propagation delay of the asynchronous input signal from
 the first bin up to that specific considered bin.
 Therefore, once the Coarse Extension Core (CEC) sends the 
\begin_inset Quotes eld
\end_inset

Fine
\begin_inset Quotes erd
\end_inset

 field, representing the bin that is hit by the input signal, it is possible
 to read from the CC the precise propagation delay up to that bin; the exact
 Fine measure, in picoseconds, is thus obtained.
 Let's briefly describe the generics of this module.
 
\shape italic
BIT_CALIBRATION
\shape default
 sets the number of samples used to build the CT, which means that after
 
\begin_inset Formula $2^{BIT\_CALIBRATION}-1$
\end_inset

 samples, the CT is ready to be used.
 
\shape italic
BIT_RESOLUTION
\shape default
 is instead the length of the calibrated Fine measure (in picoseconds) at
 the output of the Calibrator.
 The calibration on the Fine data is peformed only if FID='1', which means
 that a valid measure is coming from the CEC; otherwise, if FID='0', it
 means that an overflow is coming from the CEC, and it is passed unaltered
 through the Calibrator, apart from its bit length (
\shape italic
BIT_UNCALIBRATED
\shape default
 becomes 
\shape italic
BIT_RESOLUTION
\shape default
).
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Calibrator-working-principle."
plural "false"
caps "false"
noprefix "false"

\end_inset

 shows the overall data flow and working principle of the Calibrator.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/calibrator.png
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Calibrator working principle.
\begin_inset CommandInset label
LatexCommand label
name "fig:Calibrator-working-principle."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Overflow Counter (OC)
\end_layout

\begin_layout Subsubsection
Old Version
\end_layout

\begin_layout Standard
Th Overflow Counter (OC) is strongly related to the Coarse Extension Core
 (CEC), indeed, while the latter just signals the presence of an Overflow
 in the Coarse-Counter (by putting FID='0'), the OC counts the number of
 overflows coming from the CEC, allowing to extend the FSR of the TDC up
 to some days.
 The working principle of this older version of the OC is very simple, and
 it is based on the value of the FID field of the input data (s00_timestamp_tdat
a).
 If FID='1', we have a valid timestamp, which passes unaltered through this
 module, so the output data (m00_beltbus_tdata) is equal to the input data;
 if instead FID='0', which means that an overflow is coming from the CEC,
 a signal 
\shape italic
Overflow_cnt
\shape default
 is incremented by one and sent in output, along with FID='0'.
 Obviously, 
\shape italic
Overflow_cnt 
\shape default
has a bit-length equal to
\shape italic
 BIT_COARSE_CEC + BIT_RESOLUTION.
 
\shape default
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Timing-Diagram-of"
plural "false"
caps "false"
noprefix "false"

\end_inset

 graphically shows the data structure and the working principle of this
 module, through a timing diagram.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/std_OC_data.png
	width 90text%

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/standard_OC.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Data structure (at the top) and Timing Diagram (at the bottom) of the Overflow
 Counter.
\begin_inset CommandInset label
LatexCommand label
name "fig:Timing-Diagram-of"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
New Version
\end_layout

\begin_layout Standard
The OC has been improved in this work in order to manage the change done
 in the generic of the CEC module.
 In fact, we already said that the generic 
\shape italic
BIT_COARSE_CEC
\shape default
 is now used with a value of 4 instead of 8, in order to solve the timing
 errors that were present before and improve the Worst Negative Slack (WNS).
 However, this choice leads the CEC to signal way more overflows than it
 happened in the older version, and therefore, by also using the old version
 of the OC, we would have at the output of each channel a lot FID='0' transactio
ns.
 These continuous transactions represent a big problem and, as we saw experiment
ally, they can lead to the saturation of the TDC channel, and therefore
 to the loss of data.
 The new version of the OC, developed in this thesis work, has the scope
 to solve this issue, by introducing an output Coarse field with a different
 bit-length to the input Coarse field.
 The generic for the input data's coarse length is the same of the previous
 modules, i.e.
 
\shape italic
BIT_COARSE_CEC
\shape default
; the generic for the output data is instead 
\shape italic
BIT_COARSE.
 
\shape default
The following relation holds:
\begin_inset Formula 
\begin{equation}
BIT\_COARSE\_CEC\leq BIT\_COARSE\label{eq:OC_generics}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since the case where 
\begin_inset Formula $BIT\_COARSE\_CEC=BIT\_COARSE$
\end_inset

 behaves exactly as the older version of the Overflow Counter, described
 in the last paragraph, and since we just said that it would cause problems
 to the channel's management of the data, we will now describe just the
 useful case in which 
\begin_inset Formula $BIT\_COARSE\_CEC<BIT\_COARSE$
\end_inset

.
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Overflow-Counter-IP-Core."
plural "false"
caps "false"
noprefix "false"

\end_inset

 can be seen the IP-Core package and its generics.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/OC_IP.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Overflow Counter IP-Core.
\begin_inset CommandInset label
LatexCommand label
name "fig:Overflow-Counter-IP-Core."

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
To correctly manage the counting of the overflows, an 
\shape italic
AuxiliaryCounter
\shape default
 signal, which is (BIT_COARSE_DIFFERENCE = 
\shape italic
BIT_COARSE - BIT_COARSE_CEC
\shape default
)-wide, is in charge of counting the overflows in input (i.e.
 FID='0' coming from the CEC), and it is appended to the Coarse part of
 the input data.
 In this way, the data in output will be: [(FID = '1') & 
\shape italic
AuxiliaryCounter
\shape default
 & CoarseIn & Fine] if we have a measure as input (i.e.
 FID = '1'); otherwise, if 
\shape italic
AuxiliaryCounter 
\shape default
has reached its maximum value (i.e.
 2**BIT_COARSE_DIFFERENCE-1) and we have a new overflow in input (FID =
 '0'), 
\shape italic
AuxiliaryCounter
\shape default
 resets to 0, and the signal 
\shape italic
Overflow_cnt
\shape default
 is increased by one.
 Thus, the output will be: [(FID = '0') & 
\shape italic
Overflow_cnt
\shape default
].
 Obviously, 
\shape italic
Overflow_cnt 
\shape default
has a bit-length equal to
\shape italic
 BIT_COARSE + BIT_RESOLUTION.

\shape default
 In Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Data-structure-(at"
plural "false"
caps "false"
noprefix "false"

\end_inset

 we can see the data structure and the working principle of the improved
 Overflow Counter (OC), in the simple example of 
\shape italic
BIT_COARSE_CEC
\shape default
 = 2, 
\shape italic
BIT_COARSE
\shape default
 = 4.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/new_OC_data.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/improved_OC.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Data structure (at the top) and Timing Diagram (at the bottom) of the improved
 Overflow Counter.
\begin_inset CommandInset label
LatexCommand label
name "fig:Data-structure-(at"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It's clear that, since the FID='0' transaction (with the updated value of
 
\shape italic
Overflow_cnt
\shape default
) happens only when 
\shape italic
AuxiliaryCounter
\shape default
 goes in overflow, way less of these transactions happen at the output than
 the one happening at the input.
 The channel saturation problem is thus solved, along with the old timing
 errors coming from the CEC.
 
\end_layout

\end_body
\end_document
